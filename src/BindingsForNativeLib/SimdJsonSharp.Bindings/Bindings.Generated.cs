// THIS FILE IS AUTOGENERATED!

using System;
using System.Runtime.InteropServices;

namespace SimdJsonSharp
{
    public unsafe partial class ParsedJsonN : IDisposable
    {
        /// <summary>
        /// Pointer to the underlying native object
        /// </summary>
        public void* Handle { get; private set; }

        /// <summary>
        /// Create ParsedJsonN from a native pointer
        /// </summary>
        public ParsedJsonN(void* handle) => this.Handle = handle;

        /// <summary>
        /// create a ParsedJson container with zero capacity, call allocateCapacity to allocate memory
        /// </summary>
        public ParsedJsonN() => this.Handle = ParsedJson_ParsedJson();

        /// <summary>
        /// if needed, allocate memory so that the object is able to process JSON documents having up to len bytes and maxdepth "depth"
        /// </summary>
        public bool AllocateCapacity(long len, long maxdepth) => ParsedJson_allocateCapacity(this.Handle, (IntPtr)len, (IntPtr)maxdepth) > 0;

        /// <summary>
        /// </summary>
        public bool IsValid => ParsedJson_isValid(this.Handle) > 0;

        /// <summary>
        /// deallocate memory and set capacity to zero, called automatically by the destructor
        /// </summary>
        public void Deallocate() => ParsedJson_deallocate(this.Handle);

        /// <summary>
        /// this should be called when parsing (right before writing the tapes)
        /// </summary>
        public void Init() => ParsedJson_init(this.Handle);

        /// <summary>
        /// this should be considered a private function
        /// </summary>
        public void WriteTape(ulong val, byte c) => ParsedJson_write_tape(this.Handle, val, c);

        /// <summary>
        /// </summary>
        public void WriteTapeS64(long i) => ParsedJson_write_tape_s64(this.Handle, i);

        /// <summary>
        /// </summary>
        public void WriteTapeDouble(double d) => ParsedJson_write_tape_double(this.Handle, d);

        /// <summary>
        /// </summary>
        public uint GetCurrentLoc() => ParsedJson_get_current_loc(this.Handle);

        /// <summary>
        /// </summary>
        public void AnnotatePreviousloc(uint saved_loc, ulong val) => ParsedJson_annotate_previousloc(this.Handle, saved_loc, val);



#region DllImports
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern void* ParsedJson_ParsedJson();
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte ParsedJson_allocateCapacity(void* target, IntPtr len, IntPtr maxdepth);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte ParsedJson_isValid(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern void ParsedJson_deallocate(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern void ParsedJson_init(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern void ParsedJson_write_tape(void* target, ulong val, byte c);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern void ParsedJson_write_tape_s64(void* target, long i);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern void ParsedJson_write_tape_double(void* target, double d);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern uint ParsedJson_get_current_loc(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern void ParsedJson_annotate_previousloc(void* target, uint saved_loc, ulong val);

#endregion

        private static readonly object DisposeSync = new object();

        public void Dispose()
        {
            if (Handle != (void*) IntPtr.Zero)
            {
                lock (DisposeSync)
                {
                    if (Handle != (void*) IntPtr.Zero)
                    {
                        ParsedJson_Dispose(Handle);
                        Handle = (void*) IntPtr.Zero;
                    }
                }
            }
        }

        ~ParsedJsonN() => Dispose();

        [DllImport(SimdJsonN.NativeLib, CallingConvention = CallingConvention.Cdecl)]
        private static extern void ParsedJson_Dispose(void* target);
    }

    public unsafe partial class ParsedJsonIteratorN : IDisposable
    {
        /// <summary>
        /// Pointer to the underlying native object
        /// </summary>
        public void* Handle { get; private set; }

        /// <summary>
        /// Create ParsedJsonIteratorN from a native pointer
        /// </summary>
        public ParsedJsonIteratorN(void* handle) => this.Handle = handle;

        /// <summary>
        /// might throw InvalidJSON if ParsedJson is invalid
        /// </summary>
        public ParsedJsonIteratorN(ParsedJsonN pj_) => this.Handle = iterator_iterator(pj_.Handle);

        /// <summary>
        /// </summary>
        public bool IsOk => iterator_isOk(this.Handle) > 0;

        /// <summary>
        /// useful for debuging purposes
        /// </summary>
        public long GetTapeLocation() => (long)iterator_get_tape_location(this.Handle);

        /// <summary>
        /// useful for debuging purposes
        /// </summary>
        public long GetTapeLength() => (long)iterator_get_tape_length(this.Handle);

        /// <summary>
        /// returns the current depth (start at 1 with 0 reserved for the fictitious root node)
        /// </summary>
        public long GetDepth() => (long)iterator_get_depth(this.Handle);

        /// <summary>
        /// A scope is a series of nodes at the same depth, typically it is either an object ({) or an array ([). The root node has type 'r'.
        /// </summary>
        public byte GetScopeType() => iterator_get_scope_type(this.Handle);

        /// <summary>
        /// move forward in document order
        /// </summary>
        public bool MoveForward() => iterator_move_forward(this.Handle) > 0;

        /// <summary>
        /// retrieve the character code of what we're looking at: [{"sltfn are the possibilities
        /// </summary>
        public byte GetTokenType() => iterator_get_type(this.Handle);

        /// <summary>
        /// get the int64_t value at this node; valid only if we're at "l"
        /// </summary>
        public long GetInteger() => iterator_get_integer(this.Handle);

        /// <summary>
        /// get the string value at this node (NULL ended); valid only if we're at " note that tabs, and line endings are escaped in the returned value (see print_with_escapes) return value is valid UTF-8 It may contain NULL chars within the string: get_string_length determines the true string length.
        /// </summary>
        public sbyte* GetString() => iterator_get_string(this.Handle);

        /// <summary>
        /// </summary>
        public uint GetStringLength() => iterator_get_string_length(this.Handle);

        /// <summary>
        /// get the double value at this node; valid only if we're at "d"
        /// </summary>
        public double GetDouble() => iterator_get_double(this.Handle);

        /// <summary>
        /// </summary>
        public bool IsObjectOrArray => iterator_is_object_or_array(this.Handle) > 0;

        /// <summary>
        /// </summary>
        public bool IsObject => iterator_is_object(this.Handle) > 0;

        /// <summary>
        /// </summary>
        public bool IsArray => iterator_is_array(this.Handle) > 0;

        /// <summary>
        /// </summary>
        public bool IsString => iterator_is_string(this.Handle) > 0;

        /// <summary>
        /// </summary>
        public bool IsInteger => iterator_is_integer(this.Handle) > 0;

        /// <summary>
        /// </summary>
        public bool IsDouble => iterator_is_double(this.Handle) > 0;

        /// <summary>
        /// </summary>
        public bool IsTrue => iterator_is_true(this.Handle) > 0;

        /// <summary>
        /// </summary>
        public bool IsFalse => iterator_is_false(this.Handle) > 0;

        /// <summary>
        /// </summary>
        public bool IsNull => iterator_is_null(this.Handle) > 0;

        /// <summary>
        /// </summary>
        public static bool IsObjectOrArrayStatic(byte type) => iterator_s_is_object_or_array(type) > 0;

        /// <summary>
        /// when at {, go one level deep, looking for a given key if successful, we are left pointing at the value, if not, we are still pointing at the object ({) (in case of repeated keys, this only finds the first one) We seek the key using C's strcmp so if your JSON strings contain NULL chars, this would trigger a false positive: if you expect that to be the case, take extra precautions.
        /// </summary>
        public bool MoveToKey(sbyte* key) => iterator_move_to_key(this.Handle, key) > 0;

        /// <summary>
        /// Withing a given scope (series of nodes at the same depth within either an array or an object), we move forward. Thus, given [true, null, {"a":1}, [1,2]], we would visit true, null, { and [. At the object ({) or at the array ([), you can issue a "down" to visit their content. valid if we're not at the end of a scope (returns true).
        /// </summary>
        public bool Next() => iterator_next(this.Handle) > 0;

        /// <summary>
        /// Withing a given scope (series of nodes at the same depth within either an array or an object), we move backward. Thus, given [true, null, {"a":1}, [1,2]], we would visit ], }, null, true when starting at the end of the scope. At the object ({) or at the array ([), you can issue a "down" to visit their content.
        /// </summary>
        public bool Prev() => iterator_prev(this.Handle) > 0;

        /// <summary>
        /// Moves back to either the containing array or object (type { or [) from within a contained scope. Valid unless we are at the first level of the document
        /// </summary>
        public bool Up() => iterator_up(this.Handle) > 0;

        /// <summary>
        /// Valid if we're at a [ or { and it starts a non-empty scope; moves us to start of that deeper scope if it not empty. Thus, given [true, null, {"a":1}, [1,2]], if we are at the { node, we would move to the "a" node.
        /// </summary>
        public bool Down() => iterator_down(this.Handle) > 0;

        /// <summary>
        /// move us to the start of our current scope, a scope is a series of nodes at the same level
        /// </summary>
        public void ToStartScope() => iterator_to_start_scope(this.Handle);



#region DllImports
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern void* iterator_iterator(void* pj_);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_isOk(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern long iterator_get_tape_location(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern long iterator_get_tape_length(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern long iterator_get_depth(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_get_scope_type(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_move_forward(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_get_type(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern long iterator_get_integer(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern sbyte* iterator_get_string(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern uint iterator_get_string_length(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern double iterator_get_double(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_is_object_or_array(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_is_object(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_is_array(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_is_string(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_is_integer(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_is_double(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_is_true(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_is_false(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_is_null(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_s_is_object_or_array(byte type);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_move_to_key(void* target, sbyte* key);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_next(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_prev(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_up(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern byte iterator_down(void* target);
        [DllImport(SimdJsonN.NativeLib, CallingConvention=CallingConvention.Cdecl)]
        private static extern void iterator_to_start_scope(void* target);

#endregion

        private static readonly object DisposeSync = new object();

        public void Dispose()
        {
            if (Handle != (void*) IntPtr.Zero)
            {
                lock (DisposeSync)
                {
                    if (Handle != (void*) IntPtr.Zero)
                    {
                        iterator_Dispose(Handle);
                        Handle = (void*) IntPtr.Zero;
                    }
                }
            }
        }

        ~ParsedJsonIteratorN() => Dispose();

        [DllImport(SimdJsonN.NativeLib, CallingConvention = CallingConvention.Cdecl)]
        private static extern void iterator_Dispose(void* target);
    }
}